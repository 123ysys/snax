# SnaX Game Engine

## License
SnaX Game Engine - https://github.com/snaxgameengine/snax  
Licensed under the MIT License <http://opensource.org/licenses/MIT>.  
SPDX-License-Identifier: MIT  
Copyright (c) 2013 - 2022 Frank-Vegar Mortensen <franksvm(at)outlook(dot)com>.  

Permission is hereby  granted, free of charge, to any  person obtaining a copy
of this software and associated  documentation files (the "Software"), to deal
in the Software  without restriction, including without  limitation the rights
to  use, copy,  modify, merge,  publish, distribute,  sublicense, and/or  sell
copies  of  the Software,  and  to  permit persons  to  whom  the Software  is
furnished to do so, subject to the following conditions:  

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.  

THE SOFTWARE  IS PROVIDED "AS  IS", WITHOUT WARRANTY  OF ANY KIND,  EXPRESS OR
IMPLIED,  INCLUDING BUT  NOT  LIMITED TO  THE  WARRANTIES OF  MERCHANTABILITY,
FITNESS FOR  A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT  SHALL THE
AUTHORS  OR COPYRIGHT  HOLDERS  BE  LIABLE FOR  ANY  CLAIM,  DAMAGES OR  OTHER
LIABILITY, WHETHER IN AN ACTION OF  CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE  OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

## What is SnaX
SnaX is a fast and lightweight development tool for 3D-graphics applications based 
on a real-time, visual programming concept. Real-time because every update you make 
to your program can be viewed instantly as you develop - Visual because programming 
happens in a graphical environment, where writing code is replaced by linking 
together small, precompiled blocks of functionality called Chips.  

[![SnaX Game Engine](https://img.youtube.com/vi/nrKiPmimBGk/maxresdefault.jpg)](https://www.youtube.com/watch?v=nrKiPmimBGk)
*Promo video - Click to play on YouTube!*

Screen shots are available in the [image gallery](./Common/Gallery/)!

SnaX is built for Windows 10, using DirectX 12 for state-of-the-art graphics. 
It got a bunch of cool features including:

- An object-oriented programming design
  - Build classes and class hierarchies - Visually!
  - Add data members and functions - Visually!
  - Override and inherit - Visually!
- Real-time physics simulations using Nvidia PhysX 4
- Importers for many popular 3D-asset and texture formats
  - Including 3ds, fbx, obj, glTF and dae.
- Low-level access to the graphics pipeline:
  - Fully user-configurable material and lighting system.
  - Program all shader stages using HLSL, including compute shaders.
  - Forward or deferred rendering: You decide!
  - HDR rendering and tone mapping: Up to you!
  - Physically Based Rendering (PBR): Yes, you can!
- Fast and easy debugging
  - In-game Break Points.
  - View the current stack trace!
  - Step into your code, edit and continue!
  - Native debugging when building from source.
- Built-in performance profiling
  - Locate the bottlenecks!
  - Statistics are available real-time!
- Open source!
  - Permissive [MIT license](https://en.wikipedia.org/wiki/MIT_License) with minimal restrictions!
  - Modify the engine to your needs.
  - Create your own Chips!
  - Integrate your favorite libraries!

## SnaX Overview
Here is a schematic overview of the different parts of SnaX, and how they depend on each other:

![Schematic overview of SnaX](./Common/Overview.png?raw=true)
*Click image for larger version!*

The core engine of SnaX is quite tiny, and contains the basic functionality of any SnaX Program. 
These modules form what we can call the *SnaX Runtime*, and are together with the *Chips*, all the 
binary executable code for a Snax application (in addition to third party dependencies, of course).
The Runtime reads the *SnaX Project Files*, that is, the source code for any SnaX application. 
These files are stored in either a json or binary format, and are generated by SnaX Developer, 
the tool we use for building our applications. They describes which chips to use, how to configure 
them, and how to link them together in classes. When bundled together with the Chips and the Runtime, 
they form the application or the game you create using SnaX.

The *Chips* contain most of the functionality in SnaX - Everything from graphics, math, 
program logics to physics. Each type of chip contains a limited, well defined functionality and
interface, and when connected together with other types of chips, they form increasingly complex
functionality, up till the point where you have a complete working game or application.
Chips make up a hierarchy of types, and it is easy to derive new types from existing ones, 
for implementing all kinds of new, custom functionality. Chips are written in C++.

Chips can have an associated property dialog that can be opened in SnaX Developer, for doing
configuration settings on each individual chip.

## Getting started with SnaX
### Prerequisites
- Windows 10 (x64), D3D12 compatible graphics card.
- Visual Studio 2019 or later (Community or Professional) with C++ installed.
- Make sure you have git for Windows, version 2.7.4 or later (https://git-scm.com/download/win).
- Make sure you have CMake version **3.21** or later (https://cmake.org/download/).
- Plenty of disk space (30GB+). Most of this is reserved for temporary build files.

### How to build SnaX
- `git clone https://github.com/snaxgameengine/snax`  
- `cd snax`
- `./Setup.bat`
  - The setup script will initiate submodules, bootstrap VCPKG,
    build all dependencies, generate Visual Studio projects,
	and optionally build SnaX for you! SnaX is by default generated 
	in the ./Build/ directory.
- That's it! Build and open `SnaXDeveloper.exe` to start creating the next big thing using SnaX!

**Note about Qt:** SnaX Developer is using Qt for its UI. 
All Qt's custom build steps (UIC, MOC, RCC) are handled automatically.
If you want to edit the .ui files (user interface designs), 
you can do so by opening them in QtDesigner, located in your build directories here:  
`./vcpkg/installed/x64-windows/tools/Qt6/bin/designer.exe`

Note that projects you develop using SnaX are **not** depending on Qt,
as all window handling and user inputs are done natively in the viewer application (SnaXViewer.exe).

### How to use SnaX
There is a limited amount of documentation available:
- [User manual](./Common/Documentation/SnaXManual.pdf)
- [Tutorial 1](./Common/Documentation/Tutorial1.pdf)
- [Tutorial 2](./Common/Documentation/Tutorial1.pdf)

There are also a few examples to play with in the [./Common/Examples/](./Common/Examples/) directory.

## How to create an installer when releasing a new version of SnaX
- Make sure you have [InnoSetup](https://jrsoftware.org/isinfo.php) version 6 or later installed.
- Update version string in main.cpp.
- Update [./Common/Changelog.txt](./Common/Changelog.txt) with recent bugfixes and updates!
- Go to the Installer directory and start CreateInstaller.bat.
- Enter output path. Default is `../Build/bin/Release/`.
- Enter same version number as in main.cpp.
- Make sure to update installer to include new files.
- Build installer.
- Figure out installer checksums (MD5/SHA-256).
- Try the installer and make sure averything looks good. Try examples, physx and importers!
- Upload to web and distribute.

## Roadmap
What are some of the plans for SnaX going forward?  
The lists are not given in any specific order, nor is there given any time frame for any of the items.

### Short term
- Get rid of all binary data in project files to make them (the m3j-files) smaller and work better with version control systems.
  - **Texture**: Images should not be stored in the Texture chips, but stored as ordinary image files on disk (jpg, png, dds etc)
  - **StdGeometry**: When importing a 3D model, the geometry data is scattered around in several StdGeometry chips.
    These chips contain large arrays of geometry data that makes the project files large and unsuitable for version control system.
	The proposed solution is to gather all geometry data into a new binary file format that can be read by the chips.
  - **Skeleton**: Similar to StdGeometry, the Skeleton chip contains large amount of data (skeleton and animations) that should be moved
    to the proposed binary file format.
  - **Shader**: Shader soure code should be stored in separate .hlsl files not in the Shader chip. The bytecode should also be moved out of the chip.
- Common chips that changes their value frequently during game play should save a default value to 
  avoid cluttering the source code (m3j-files). This is also to make the source work better with version control systems.
  - This applies to chips: **Value**, **Vector**, **Matrix**, **Text**, and possible more.
- Add JSON parser/writer chips using rapid-json.
- Add proper localization support. This is for the most part currently missing. 
  We are talking proper text processing (eg upper/lower case conversion), number/date formatting etc.
- Get rid of LibXml2. Project files are no longer to be stored in xml-format (m3x-files). This eliminates the need of libXml2.
  Still, we have the xml-parser chips, but we should make them use rapid-xml or something else.
- Start experimenting with VR support.

### Long term
- Add Vulkan support. This comes in addition to, or as a replacement of D3D12. To properly support multiple graphics api we should
  create a graphics backend for this, but this is a large work.
  Maybe we instead could use something like [bgfx](https://github.com/bkaradzic/bgfx#bgfx---cross-platform-rendering-library).
- Add support for deploying to multiple platforms, possibly: Android, linux, xbox, playstation, web, etc.
- Modernize Snax Developer. Write it from scratch, most likely. With or without Qt - Alternatives should be explored.

## Third party dependencies
SnaX depends on many open source libraries, including (*license in parentheses*):

- [boost](https://www.boost.org/) (boost)
- [libxml2](https://gitlab.gnome.org/GNOME/libxml2/-/wikis/home) (MIT)
- [zlib](https://zlib.net/) (ZLIB)
- [libiconv](https://www.gnu.org/software/libiconv/) (LGPL-2)
- [lzma](https://github.com/xz-mirror/xz) (Public-Domain LGPL-2.1-or-later GPL-2.0-or-later GPL-3.0-or-later)
- [magic-enum](https://github.com/Neargye/magic_enum) (MIT)
- [rapid-json](https://rapidjson.org/) (MIT)
- [DirectXTex](https://github.com/microsoft/DirectXTex) (MIT)
- [DirectXTK12](https://github.com/microsoft/DirectXTK12) (MIT)
- [AssImp](https://github.com/assimp/assimp) (BSD-3-Clause)
- [SDL2](https://www.libsdl.org/) (ZLIB)
- [PhysX](https://github.com/NVIDIAGameWorks/PhysX) (BSD-3-Clause)
- [ilmola/generator](https://github.com/ilmola/generator)\* (LGPL-2.1)
- [HBAO+](https://github.com/NVIDIAGameWorks/HBAOPlus)\* (Nvidia Source Code License)

Most of these libraries are managed and built by [VCPKG](https://vcpkg.io/en/index.html) (\* excepted).

Note that our [Primitives](./Primitives/) dynamic library is licensed under LGPL-2.1, 
because of the license terms of [ilmola/generator](https://github.com/ilmola/generator).

### Additional dependencies for *SnaX Developer* 
Note that these are not needed by the games or applications you develop using SnaX. 
It is only the development tool itself that uses Qt, not the software created by using it.

- [Qt](https://www.qt.io/) (LGPL/GPL)
  - brotli
  - bz2
  - freetype
  - harfbuzz
  - pcre-2
  - libpng
  - icu
- [DirectXTK](https://github.com/microsoft/DirectXTK) (MIT)
- Icons by [Freepik @ flaticon.com](https://www.flaticon.com/authors/freepik)
